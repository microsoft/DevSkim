{
  "version": 3,
  "sources": ["../../node_modules/dagre-d3-es/src/graphlib/json.js", "../../node_modules/mermaid/src/dagre-wrapper/mermaid-graphlib.js", "../../node_modules/mermaid/src/dagre-wrapper/clusters.js", "../../node_modules/mermaid/src/dagre-wrapper/index.js"],
  "sourcesContent": ["import * as _ from 'lodash-es';\nimport { Graph } from './graph.js';\n\nexport { write, read };\n\nfunction write(g) {\n  var json = {\n    options: {\n      directed: g.isDirected(),\n      multigraph: g.isMultigraph(),\n      compound: g.isCompound(),\n    },\n    nodes: writeNodes(g),\n    edges: writeEdges(g),\n  };\n  if (!_.isUndefined(g.graph())) {\n    json.value = _.clone(g.graph());\n  }\n  return json;\n}\n\nfunction writeNodes(g) {\n  return _.map(g.nodes(), function (v) {\n    var nodeValue = g.node(v);\n    var parent = g.parent(v);\n    var node = { v: v };\n    if (!_.isUndefined(nodeValue)) {\n      node.value = nodeValue;\n    }\n    if (!_.isUndefined(parent)) {\n      node.parent = parent;\n    }\n    return node;\n  });\n}\n\nfunction writeEdges(g) {\n  return _.map(g.edges(), function (e) {\n    var edgeValue = g.edge(e);\n    var edge = { v: e.v, w: e.w };\n    if (!_.isUndefined(e.name)) {\n      edge.name = e.name;\n    }\n    if (!_.isUndefined(edgeValue)) {\n      edge.value = edgeValue;\n    }\n    return edge;\n  });\n}\n\nfunction read(json) {\n  var g = new Graph(json.options).setGraph(json.value);\n  _.each(json.nodes, function (entry) {\n    g.setNode(entry.v, entry.value);\n    if (entry.parent) {\n      g.setParent(entry.v, entry.parent);\n    }\n  });\n  _.each(json.edges, function (entry) {\n    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);\n  });\n  return g;\n}\n", "/** Decorates with functions required by mermaids dagre-wrapper. */\nimport { log } from '../logger';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport * as graphlib from 'dagre-d3-es/src/graphlib/index.js';\n\nexport let clusterDb = {};\nlet descendants = {};\nlet parents = {};\n\nexport const clear = () => {\n  descendants = {};\n  parents = {};\n  clusterDb = {};\n};\n\nconst isDescendant = (id, ancenstorId) => {\n  // if (id === ancenstorId) return true;\n\n  log.trace('In isDecendant', ancenstorId, ' ', id, ' = ', descendants[ancenstorId].includes(id));\n  if (descendants[ancenstorId].includes(id)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst edgeInCluster = (edge, clusterId) => {\n  log.info('Decendants of ', clusterId, ' is ', descendants[clusterId]);\n  log.info('Edge is ', edge);\n  // Edges to/from the cluster is not in the cluster, they are in the parent\n  if (edge.v === clusterId) {\n    return false;\n  }\n  if (edge.w === clusterId) {\n    return false;\n  }\n\n  if (!descendants[clusterId]) {\n    log.debug('Tilt, ', clusterId, ',not in decendants');\n    return false;\n  }\n  return (\n    descendants[clusterId].includes(edge.v) ||\n    isDescendant(edge.v, clusterId) ||\n    isDescendant(edge.w, clusterId) ||\n    descendants[clusterId].includes(edge.w)\n  );\n};\n\nconst copy = (clusterId, graph, newGraph, rootId) => {\n  log.warn(\n    'Copying children of ',\n    clusterId,\n    'root',\n    rootId,\n    'data',\n    graph.node(clusterId),\n    rootId\n  );\n  const nodes = graph.children(clusterId) || [];\n\n  // Include cluster node if it is not the root\n  if (clusterId !== rootId) {\n    nodes.push(clusterId);\n  }\n\n  log.warn('Copying (nodes) clusterId', clusterId, 'nodes', nodes);\n\n  nodes.forEach((node) => {\n    if (graph.children(node).length > 0) {\n      copy(node, graph, newGraph, rootId);\n    } else {\n      const data = graph.node(node);\n      log.info('cp ', node, ' to ', rootId, ' with parent ', clusterId); //,node, data, ' parent is ', clusterId);\n      newGraph.setNode(node, data);\n      if (rootId !== graph.parent(node)) {\n        log.warn('Setting parent', node, graph.parent(node));\n        newGraph.setParent(node, graph.parent(node));\n      }\n\n      if (clusterId !== rootId && node !== clusterId) {\n        log.debug('Setting parent', node, clusterId);\n        newGraph.setParent(node, clusterId);\n      } else {\n        log.info('In copy ', clusterId, 'root', rootId, 'data', graph.node(clusterId), rootId);\n        log.debug(\n          'Not Setting parent for node=',\n          node,\n          'cluster!==rootId',\n          clusterId !== rootId,\n          'node!==clusterId',\n          node !== clusterId\n        );\n      }\n      const edges = graph.edges(node);\n      log.debug('Copying Edges', edges);\n      edges.forEach((edge) => {\n        log.info('Edge', edge);\n        const data = graph.edge(edge.v, edge.w, edge.name);\n        log.info('Edge data', data, rootId);\n        try {\n          // Do not copy edges in and out of the root cluster, they belong to the parent graph\n          if (edgeInCluster(edge, rootId)) {\n            log.info('Copying as ', edge.v, edge.w, data, edge.name);\n            newGraph.setEdge(edge.v, edge.w, data, edge.name);\n            log.info('newGraph edges ', newGraph.edges(), newGraph.edge(newGraph.edges()[0]));\n          } else {\n            log.info(\n              'Skipping copy of edge ',\n              edge.v,\n              '-->',\n              edge.w,\n              ' rootId: ',\n              rootId,\n              ' clusterId:',\n              clusterId\n            );\n          }\n        } catch (e) {\n          log.error(e);\n        }\n      });\n    }\n    log.debug('Removing node', node);\n    graph.removeNode(node);\n  });\n};\nexport const extractDescendants = (id, graph) => {\n  // log.debug('Extracting ', id);\n  const children = graph.children(id);\n  let res = [...children];\n\n  for (const child of children) {\n    parents[child] = id;\n    res = [...res, ...extractDescendants(child, graph)];\n  }\n\n  return res;\n};\n\n/**\n * Validates the graph, checking that all parent child relation points to existing nodes and that\n * edges between nodes also ia correct. When not correct the function logs the discrepancies.\n *\n * @param graph\n */\nexport const validate = (graph) => {\n  const edges = graph.edges();\n  log.trace('Edges: ', edges);\n  for (const edge of edges) {\n    if (graph.children(edge.v).length > 0) {\n      log.trace('The node ', edge.v, ' is part of and edge even though it has children');\n      return false;\n    }\n    if (graph.children(edge.w).length > 0) {\n      log.trace('The node ', edge.w, ' is part of and edge even though it has children');\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Finds a child that is not a cluster. When faking an edge between a node and a cluster.\n *\n * @param id\n * @param {any} graph\n */\nexport const findNonClusterChild = (id, graph) => {\n  // const node = graph.node(id);\n  log.trace('Searching', id);\n  // const children = graph.children(id).reverse();\n  const children = graph.children(id); //.reverse();\n  log.trace('Searching children of id ', id, children);\n  if (children.length < 1) {\n    log.trace('This is a valid node', id);\n    return id;\n  }\n  for (const child of children) {\n    const _id = findNonClusterChild(child, graph);\n    if (_id) {\n      log.trace('Found replacement for', id, ' => ', _id);\n      return _id;\n    }\n  }\n};\n\nconst getAnchorId = (id) => {\n  if (!clusterDb[id]) {\n    return id;\n  }\n  // If the cluster has no external connections\n  if (!clusterDb[id].externalConnections) {\n    return id;\n  }\n\n  // Return the replacement node\n  if (clusterDb[id]) {\n    return clusterDb[id].id;\n  }\n  return id;\n};\n\nexport const adjustClustersAndEdges = (graph, depth) => {\n  if (!graph || depth > 10) {\n    log.debug('Opting out, no graph ');\n    return;\n  } else {\n    log.debug('Opting in, graph ');\n  }\n  // Go through the nodes and for each cluster found, save a replacement node, this can be used when\n  // faking a link to a cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    if (children.length > 0) {\n      log.warn(\n        'Cluster identified',\n        id,\n        ' Replacement id in edges: ',\n        findNonClusterChild(id, graph)\n      );\n      descendants[id] = extractDescendants(id, graph);\n      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };\n    }\n  });\n\n  // Check incoming and outgoing edges for each cluster\n  graph.nodes().forEach(function (id) {\n    const children = graph.children(id);\n    const edges = graph.edges();\n    if (children.length > 0) {\n      log.debug('Cluster identified', id, descendants);\n      edges.forEach((edge) => {\n        // log.debug('Edge, decendants: ', edge, decendants[id]);\n\n        // Check if any edge leaves the cluster (not the actual cluster, that's a link from the box)\n        if (edge.v !== id && edge.w !== id) {\n          // Any edge where either the one of the nodes is descending to the cluster but not the other\n          // if (decendants[id].indexOf(edge.v) < 0 && decendants[id].indexOf(edge.w) < 0) {\n\n          const d1 = isDescendant(edge.v, id);\n          const d2 = isDescendant(edge.w, id);\n\n          // d1 xor d2 - if either d1 is true and d2 is false or the other way around\n          if (d1 ^ d2) {\n            log.warn('Edge: ', edge, ' leaves cluster ', id);\n            log.warn('Decendants of XXX ', id, ': ', descendants[id]);\n            clusterDb[id].externalConnections = true;\n          }\n        }\n      });\n    } else {\n      log.debug('Not a cluster ', id, descendants);\n    }\n  });\n\n  // For clusters with incoming and/or outgoing edges translate those edges to a real node\n  // in the cluster in order to fake the edge\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.warn('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(graph.edge(e)));\n\n    let v = e.v;\n    let w = e.w;\n    // Check if link is either from or to a cluster\n    log.warn(\n      'Fix XXX',\n      clusterDb,\n      'ids:',\n      e.v,\n      e.w,\n      'Translating: ',\n      clusterDb[e.v],\n      ' --- ',\n      clusterDb[e.w]\n    );\n    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {\n      log.warn('Fixing and trixing link to self - removing XXX', e.v, e.w, e.name);\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      const specialId = e.w + '---' + e.v;\n      graph.setNode(specialId, {\n        domId: specialId,\n        id: specialId,\n        labelStyle: '',\n        labelText: edge.label,\n        padding: 0,\n        shape: 'labelRect',\n        style: '',\n      });\n      const edge1 = JSON.parse(JSON.stringify(edge));\n      const edge2 = JSON.parse(JSON.stringify(edge));\n      edge1.label = '';\n      edge1.arrowTypeEnd = 'none';\n      edge2.label = '';\n      edge1.fromCluster = e.v;\n      edge2.toCluster = e.v;\n\n      graph.setEdge(v, specialId, edge1, e.name + '-cyclic-special');\n      graph.setEdge(specialId, w, edge2, e.name + '-cyclic-special');\n    } else if (clusterDb[e.v] || clusterDb[e.w]) {\n      log.warn('Fixing and trixing - removing XXX', e.v, e.w, e.name);\n      v = getAnchorId(e.v);\n      w = getAnchorId(e.w);\n      graph.removeEdge(e.v, e.w, e.name);\n      if (v !== e.v) {\n        edge.fromCluster = e.v;\n      }\n      if (w !== e.w) {\n        edge.toCluster = e.w;\n      }\n      log.warn('Fix Replacing with XXX', v, w, e.name);\n      graph.setEdge(v, w, edge, e.name);\n    }\n  });\n  log.warn('Adjusted Graph', graphlibJson.write(graph));\n  extractor(graph, 0);\n\n  log.trace(clusterDb);\n\n  // Remove references to extracted cluster\n  // graph.edges().forEach(edge => {\n  //   if (isDecendant(edge.v, clusterId) || isDecendant(edge.w, clusterId)) {\n  //     graph.removeEdge(edge);\n  //   }\n  // });\n};\n\nexport const extractor = (graph, depth) => {\n  log.warn('extractor - ', depth, graphlibJson.write(graph), graph.children('D'));\n  if (depth > 10) {\n    log.error('Bailing out');\n    return;\n  }\n  // For clusters without incoming and/or outgoing edges, create a new cluster-node\n  // containing the nodes and edges in the custer in a new graph\n  // for (let i = 0;)\n  let nodes = graph.nodes();\n  let hasChildren = false;\n  for (const node of nodes) {\n    const children = graph.children(node);\n    hasChildren = hasChildren || children.length > 0;\n  }\n\n  if (!hasChildren) {\n    log.debug('Done, no node has children', graph.nodes());\n    return;\n  }\n  // const clusters = Object.keys(clusterDb);\n  // clusters.forEach(clusterId => {\n  log.debug('Nodes = ', nodes, depth);\n  for (const node of nodes) {\n    log.debug(\n      'Extracting node',\n      node,\n      clusterDb,\n      clusterDb[node] && !clusterDb[node].externalConnections,\n      !graph.parent(node),\n      graph.node(node),\n      graph.children('D'),\n      ' Depth ',\n      depth\n    );\n    // Note that the node might have been removed after the Object.keys call so better check\n    // that it still is in the game\n    if (!clusterDb[node]) {\n      // Skip if the node is not a cluster\n      log.debug('Not a cluster', node, depth);\n      // break;\n    } else if (\n      !clusterDb[node].externalConnections &&\n      // !graph.parent(node) &&\n      graph.children(node) &&\n      graph.children(node).length > 0\n    ) {\n      log.warn(\n        'Cluster without external connections, without a parent and with children',\n        node,\n        depth\n      );\n\n      const graphSettings = graph.graph();\n      let dir = graphSettings.rankdir === 'TB' ? 'LR' : 'TB';\n      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {\n        dir = clusterDb[node].clusterData.dir;\n        log.warn('Fixing dir', clusterDb[node].clusterData.dir, dir);\n      }\n\n      const clusterGraph = new graphlib.Graph({\n        multigraph: true,\n        compound: true,\n      })\n        .setGraph({\n          rankdir: dir, // Todo: set proper spacing\n          nodesep: 50,\n          ranksep: 50,\n          marginx: 8,\n          marginy: 8,\n        })\n        .setDefaultEdgeLabel(function () {\n          return {};\n        });\n\n      log.warn('Old graph before copy', graphlibJson.write(graph));\n      copy(node, graph, clusterGraph, node);\n      graph.setNode(node, {\n        clusterNode: true,\n        id: node,\n        clusterData: clusterDb[node].clusterData,\n        labelText: clusterDb[node].labelText,\n        graph: clusterGraph,\n      });\n      log.warn('New graph after copy node: (', node, ')', graphlibJson.write(clusterGraph));\n      log.debug('Old graph after copy', graphlibJson.write(graph));\n    } else {\n      log.warn(\n        'Cluster ** ',\n        node,\n        ' **not meeting the criteria !externalConnections:',\n        !clusterDb[node].externalConnections,\n        ' no parent: ',\n        !graph.parent(node),\n        ' children ',\n        graph.children(node) && graph.children(node).length > 0,\n        graph.children('D'),\n        depth\n      );\n      log.debug(clusterDb);\n    }\n  }\n\n  nodes = graph.nodes();\n  log.warn('New list of nodes', nodes);\n  for (const node of nodes) {\n    const data = graph.node(node);\n    log.warn(' Now next level', node, data);\n    if (data.clusterNode) {\n      extractor(data.graph, depth + 1);\n    }\n  }\n};\n\nconst sorter = (graph, nodes) => {\n  if (nodes.length === 0) {\n    return [];\n  }\n  let result = Object.assign(nodes);\n  nodes.forEach((node) => {\n    const children = graph.children(node);\n    const sorted = sorter(graph, children);\n    result = [...result, ...sorted];\n  });\n\n  return result;\n};\n\nexport const sortNodesByHierarchy = (graph) => sorter(graph, graph.children());\n", "import intersectRect from './intersect/intersect-rect';\nimport { log } from '../logger';\nimport createLabel from './createLabel';\nimport { createText } from '../rendering-util/createText';\nimport { select } from 'd3';\nimport { getConfig } from '../config';\nimport { evaluate } from '../diagrams/common/common';\n\nconst rect = (parent, node) => {\n  log.info('Creating subgraph rect for ', node.id, node);\n\n  // Add outer g element\n  const shapeSvg = parent\n    .insert('g')\n    .attr('class', 'cluster' + (node.class ? ' ' + node.class : ''))\n    .attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const useHtmlLabels = evaluate(getConfig().flowchart.htmlLabels);\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n\n  // const text = label\n  //   .node()\n  //   .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n  const text =\n    node.labelType === 'markdown'\n      ? createText(label, node.labelText, { style: node.labelStyle, useHtmlLabels })\n      : label.node().appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;\n  if (node.width <= bbox.width + padding) {\n    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  log.trace('Data ', node, JSON.stringify(node));\n  // center the rect around its coordinate\n  rect\n    .attr('style', node.style)\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - width / 2)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width)\n    .attr('height', node.height + padding);\n\n  if (useHtmlLabels) {\n    label.attr(\n      'transform',\n      // This puts the labal on top of the box instead of inside it\n      'translate(' + (node.x - bbox.width / 2) + ', ' + (node.y - node.height / 2) + ')'\n    );\n  } else {\n    label.attr(\n      'transform',\n      // This puts the labal on top of the box instead of inside it\n      'translate(' + node.x + ', ' + (node.y - node.height / 2) + ')'\n    );\n  }\n  // Center the label\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\n/**\n * Non visible cluster where the note is group with its\n *\n * @param {any} parent\n * @param {any} node\n * @returns {any} ShapeSvg\n */\nconst noteGroup = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', 'note-cluster').attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('rx', node.rx)\n    .attr('ry', node.ry)\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding)\n    .attr('fill', 'none');\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\nconst roundedWithTitle = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  // Create the label and insert it after the rect\n  const label = shapeSvg.insert('g').attr('class', 'cluster-label');\n  const innerRect = shapeSvg.append('rect');\n\n  const text = label\n    .node()\n    .appendChild(createLabel(node.labelText, node.labelStyle, undefined, true));\n\n  // Get the size of the label\n  let bbox = text.getBBox();\n  if (evaluate(getConfig().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = select(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr('width', bbox.width);\n    dv.attr('height', bbox.height);\n  }\n  bbox = text.getBBox();\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;\n  if (node.width <= bbox.width + node.padding) {\n    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;\n  } else {\n    node.diff = -node.padding / 2;\n  }\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'outer')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding);\n  innerRect\n    .attr('class', 'inner')\n    .attr('x', node.x - width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2 - halfPadding + bbox.height - 1)\n    .attr('width', width + padding)\n    .attr('height', node.height + padding - bbox.height - 3);\n\n  // Center the label\n  label.attr(\n    'transform',\n    'translate(' +\n      (node.x - bbox.width / 2) +\n      ', ' +\n      (node.y -\n        node.height / 2 -\n        node.padding / 3 +\n        (evaluate(getConfig().flowchart.htmlLabels) ? 5 : 3)) +\n      ')'\n  );\n\n  const rectBox = rect.node().getBBox();\n  node.height = rectBox.height;\n\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst divider = (parent, node) => {\n  // Add outer g element\n  const shapeSvg = parent.insert('g').attr('class', node.classes).attr('id', node.id);\n\n  // add the rect\n  const rect = shapeSvg.insert('rect', ':first-child');\n\n  const padding = 0 * node.padding;\n  const halfPadding = padding / 2;\n\n  // center the rect around its coordinate\n  rect\n    .attr('class', 'divider')\n    .attr('x', node.x - node.width / 2 - halfPadding)\n    .attr('y', node.y - node.height / 2)\n    .attr('width', node.width + padding)\n    .attr('height', node.height + padding);\n\n  const rectBox = rect.node().getBBox();\n  node.width = rectBox.width;\n  node.height = rectBox.height;\n  node.diff = -node.padding / 2;\n  node.intersect = function (point) {\n    return intersectRect(node, point);\n  };\n\n  return shapeSvg;\n};\n\nconst shapes = { rect, roundedWithTitle, noteGroup, divider };\n\nlet clusterElems = {};\n\nexport const insertCluster = (elem, node) => {\n  log.trace('Inserting cluster');\n  const shape = node.shape || 'rect';\n  clusterElems[node.id] = shapes[shape](elem, node);\n};\nexport const getClusterTitleWidth = (elem, node) => {\n  const label = createLabel(node.labelText, node.labelStyle, undefined, true);\n  elem.node().appendChild(label);\n  const width = label.getBBox().width;\n  elem.node().removeChild(label);\n  return width;\n};\n\nexport const clear = () => {\n  clusterElems = {};\n};\n\nexport const positionCluster = (node) => {\n  log.info('Position cluster (' + node.id + ', ' + node.x + ', ' + node.y + ')');\n  const el = clusterElems[node.id];\n\n  el.attr('transform', 'translate(' + node.x + ', ' + node.y + ')');\n};\n", "import { layout as dagreLayout } from 'dagre-d3-es/src/dagre/index.js';\nimport * as graphlibJson from 'dagre-d3-es/src/graphlib/json.js';\nimport insertMarkers from './markers';\nimport { updateNodeBounds } from './shapes/util';\nimport {\n  clear as clearGraphlib,\n  clusterDb,\n  adjustClustersAndEdges,\n  findNonClusterChild,\n  sortNodesByHierarchy,\n} from './mermaid-graphlib';\nimport { insertNode, positionNode, clear as clearNodes, setNodeElem } from './nodes';\nimport { insertCluster, clear as clearClusters } from './clusters';\nimport { insertEdgeLabel, positionEdgeLabel, insertEdge, clear as clearEdges } from './edges';\nimport { log } from '../logger';\n\nconst recursiveRender = (_elem, graph, diagramtype, parentCluster) => {\n  log.info('Graph in recursive render: XXX', graphlibJson.write(graph), parentCluster);\n  const dir = graph.graph().rankdir;\n  log.trace('Dir in recursive render - dir:', dir);\n\n  const elem = _elem.insert('g').attr('class', 'root');\n  if (!graph.nodes()) {\n    log.info('No nodes found for', graph);\n  } else {\n    log.info('Recursive render XXX', graph.nodes());\n  }\n  if (graph.edges().length > 0) {\n    log.trace('Recursive edges', graph.edge(graph.edges()[0]));\n  }\n  const clusters = elem.insert('g').attr('class', 'clusters');\n  const edgePaths = elem.insert('g').attr('class', 'edgePaths');\n  const edgeLabels = elem.insert('g').attr('class', 'edgeLabels');\n  const nodes = elem.insert('g').attr('class', 'nodes');\n\n  // Insert nodes, this will insert them into the dom and each node will get a size. The size is updated\n  // to the abstract node and is later used by dagre for the layout\n  graph.nodes().forEach(function (v) {\n    const node = graph.node(v);\n    if (parentCluster !== undefined) {\n      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));\n      // data.clusterPositioning = true;\n      log.info('Setting data for cluster XXX (', v, ') ', data, parentCluster);\n      graph.setNode(parentCluster.id, data);\n      if (!graph.parent(v)) {\n        log.trace('Setting parent', v, parentCluster.id);\n        graph.setParent(v, parentCluster.id, data);\n      }\n    }\n    log.info('(Insert) Node XXX' + v + ': ' + JSON.stringify(graph.node(v)));\n    if (node && node.clusterNode) {\n      // const children = graph.children(v);\n      log.info('Cluster identified', v, node.width, graph.node(v));\n      const o = recursiveRender(nodes, node.graph, diagramtype, graph.node(v));\n      const newEl = o.elem;\n      updateNodeBounds(node, newEl);\n      node.diff = o.diff || 0;\n      log.info('Node bounds (abc123)', v, node, node.width, node.x, node.y);\n      setNodeElem(newEl, node);\n\n      log.warn('Recursive render complete ', newEl, node);\n    } else {\n      if (graph.children(v).length > 0) {\n        // This is a cluster but not to be rendered recursively\n        // Render as before\n        log.info('Cluster - the non recursive path XXX', v, node.id, node, graph);\n        log.info(findNonClusterChild(node.id, graph));\n        clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };\n        // insertCluster(clusters, graph.node(v));\n      } else {\n        log.info('Node - the non recursive path', v, node.id, node);\n        insertNode(nodes, graph.node(v), dir);\n      }\n    }\n  });\n\n  // Insert labels, this will insert them into the dom so that the width can be calculated\n  // Also figure out which edges point to/from clusters and adjust them accordingly\n  // Edges from/to clusters really points to the first child in the cluster.\n  // TODO: pick optimal child in the cluster to us as link anchor\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e.v, e.w, e.name);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ', e, ' ', JSON.stringify(graph.edge(e)));\n\n    // Check if link is either from or to a cluster\n    log.info('Fix', clusterDb, 'ids:', e.v, e.w, 'Translateing: ', clusterDb[e.v], clusterDb[e.w]);\n    insertEdgeLabel(edgeLabels, edge);\n  });\n\n  graph.edges().forEach(function (e) {\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(e));\n  });\n  log.info('#############################################');\n  log.info('###                Layout                 ###');\n  log.info('#############################################');\n  log.info(graph);\n  dagreLayout(graph);\n  log.info('Graph after layout:', graphlibJson.write(graph));\n  // Move the nodes to the correct place\n  let diff = 0;\n  sortNodesByHierarchy(graph).forEach(function (v) {\n    const node = graph.node(v);\n    log.info('Position ' + v + ': ' + JSON.stringify(graph.node(v)));\n    log.info(\n      'Position ' + v + ': (' + node.x,\n      ',' + node.y,\n      ') width: ',\n      node.width,\n      ' height: ',\n      node.height\n    );\n    if (node && node.clusterNode) {\n      // clusterDb[node.id].node = node;\n\n      positionNode(node);\n    } else {\n      // Non cluster node\n      if (graph.children(v).length > 0) {\n        // A cluster in the non-recursive way\n        // positionCluster(node);\n        insertCluster(clusters, node);\n        clusterDb[node.id].node = node;\n      } else {\n        positionNode(node);\n      }\n    }\n  });\n\n  // Move the edge labels to the correct place after layout\n  graph.edges().forEach(function (e) {\n    const edge = graph.edge(e);\n    log.info('Edge ' + e.v + ' -> ' + e.w + ': ' + JSON.stringify(edge), edge);\n\n    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph);\n    positionEdgeLabel(edge, paths);\n  });\n\n  graph.nodes().forEach(function (v) {\n    const n = graph.node(v);\n    log.info(v, n.type, n.diff);\n    if (n.type === 'group') {\n      diff = n.diff;\n    }\n  });\n  return { elem, diff };\n};\n\nexport const render = (elem, graph, markers, diagramtype, id) => {\n  insertMarkers(elem, markers, diagramtype, id);\n  clearNodes();\n  clearEdges();\n  clearClusters();\n  clearGraphlib();\n\n  log.warn('Graph at first:', graphlibJson.write(graph));\n  adjustClustersAndEdges(graph);\n  log.warn('Graph after:', graphlibJson.write(graph));\n  // log.warn('Graph ever  after:', graphlibJson.write(graph.node('A').graph));\n  recursiveRender(elem, graph, diagramtype);\n};\n\n// const shapeDefinitions = {};\n// export const addShape = ({ shapeType: fun }) => {\n//   shapeDefinitions[shapeType] = fun;\n// };\n\n// const arrowDefinitions = {};\n// export const addArrow = ({ arrowType: fun }) => {\n//   arrowDefinitions[arrowType] = fun;\n// };\n"],
  "mappings": "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",
  "names": ["write", "g", "json", "writeNodes", "writeEdges", "isUndefined_default", "clone_default", "map_default", "v", "nodeValue", "parent", "node", "e", "edgeValue", "edge", "clusterDb", "descendants", "parents", "clear", "isDescendant", "id", "ancenstorId", "log", "edgeInCluster", "edge", "clusterId", "copy", "graph", "newGraph", "rootId", "nodes", "node", "data", "edges", "e", "extractDescendants", "children", "res", "child", "findNonClusterChild", "_id", "getAnchorId", "adjustClustersAndEdges", "depth", "d1", "d2", "v", "w", "specialId", "edge1", "edge2", "write", "extractor", "hasChildren", "dir", "clusterGraph", "Graph", "sorter", "result", "sorted", "sortNodesByHierarchy", "rect", "parent", "shapeSvg", "useHtmlLabels", "evaluate", "getConfig", "label", "text", "createText", "createLabel$1", "bbox", "div", "dv", "select_default", "padding", "halfPadding", "width", "rectBox", "point", "intersectRect$1", "noteGroup", "roundedWithTitle", "innerRect", "divider", "shapes", "clusterElems", "insertCluster", "elem", "shape", "recursiveRender", "_elem", "diagramtype", "parentCluster", "clusters", "edgePaths", "edgeLabels", "o", "newEl", "updateNodeBounds", "setNodeElem", "insertNode", "insertEdgeLabel", "dagreLayout", "diff", "positionNode", "paths", "insertEdge", "positionEdgeLabel", "n", "render", "markers", "insertMarkers$1", "clearNodes", "clearEdges", "clearClusters", "clearGraphlib"]
}
